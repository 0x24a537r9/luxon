<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/impl/util.js | Luxon</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<style>.luxon-title {font-size: 22px; color: black;}</style><meta name="description" content="Immutable date wrapper"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Luxon"><meta property="twitter:description" content="Immutable date wrapper"></head>
<body class="layout-container" data-ice="rootContainer">

<header><a href="../index.html" class="luxon-title">Luxon</a>
  <a href="./">Manual</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/moment/luxon"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/datetime.js~DateTime.html">DateTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/duration.js~Duration.html">Duration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/info.js~Info.html">Info</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/interval.js~Interval.html">Interval</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/settings.js~Settings.html">Settings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/zone.js~Zone.html">Zone</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/impl/util.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { Duration } from &apos;../duration&apos;;
import { DateTime } from &apos;../datetime&apos;;
import { Zone } from &apos;../zone&apos;;
import { LocalZone } from &apos;../zones/localZone&apos;;
import { IANAZone } from &apos;../zones/IANAZone&apos;;
import { FixedOffsetZone } from &apos;../zones/fixedOffsetZone&apos;;
import { Settings } from &apos;../settings&apos;;
import { InvalidArgumentError } from &apos;../errors&apos;;

/*
  This is just a junk drawer, containing anything used across multiple classes.
  Because Luxon is small(ish), this should stay small and we won&apos;t worry about splitting
  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.
*/

/**
 * @private
 */

export class Util {
  // TYPES

  static isUndefined(o) {
    return typeof o === &apos;undefined&apos;;
  }

  static isNumber(o) {
    return typeof o === &apos;number&apos;;
  }

  static isString(o) {
    return typeof o === &apos;string&apos;;
  }

  static isDate(o) {
    return Object.prototype.toString.call(o) === &apos;[object Date]&apos;;
  }

  // OBJECTS AND ARRAYS

  static maybeArray(thing) {
    return Array.isArray(thing) ? thing : [thing];
  }

  static bestBy(arr, by, compare) {
    return arr.reduce((best, next) =&gt; {
      const pair = [by(next), next];
      if (!best) {
        return pair;
      } else if (compare.apply(null, [best[0], pair[0]]) === best[0]) {
        return best;
      } else {
        return pair;
      }
    }, null)[1];
  }

  static pick(obj, keys) {
    return keys.reduce((a, k) =&gt; {
      a[k] = obj[k];
      return a;
    }, {});
  }

  // NUMBERS AND STRINGS

  static numberBetween(thing, bottom, top) {
    return Util.isNumber(thing) &amp;&amp; thing &gt;= bottom &amp;&amp; thing &lt;= top;
  }

  static padStart(input, n = 2) {
    return (&apos;0&apos;.repeat(n) + input).slice(-n);
  }

  static parseMillis(fraction) {
    if (fraction) {
      const f = parseFloat(&apos;0.&apos; + fraction) * 1000;
      return Math.round(f);
    } else {
      return 0;
    }
  }

  // DATE BASICS

  static isLeapYear(year) {
    return year % 4 === 0 &amp;&amp; (year % 100 !== 0 || year % 400 === 0);
  }

  static daysInYear(year) {
    return Util.isLeapYear(year) ? 366 : 365;
  }

  static daysInMonth(year, month) {
    if (month === 2) {
      return Util.isLeapYear(year) ? 29 : 28;
    } else {
      return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1];
    }
  }

  static untruncateYear(year) {
    if (year &gt; 99) {
      return year;
    } else return year &gt; 60 ? 1900 + year : 2000 + year;
  }

  // PARSING

  static parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
    const date = new Date(ts),
      intl = {
        hour12: false,
        year: &apos;numeric&apos;,
        month: &apos;2-digit&apos;,
        day: &apos;2-digit&apos;,
        hour: &apos;2-digit&apos;,
        minute: &apos;2-digit&apos;
      };

    if (timeZone) {
      intl.timeZone = timeZone;
    }

    const modified = Object.assign({ timeZoneName: offsetFormat }, intl),
      hasIntl = Util.hasIntl();

    if (hasIntl &amp;&amp; Util.hasFormatToParts()) {
      const parsed = new Intl.DateTimeFormat(locale, modified)
        .formatToParts(date)
        .find(m =&gt; m.type.toLowerCase() === &apos;timezonename&apos;);
      return parsed ? parsed.value : null;
    } else if (hasIntl) {
      // this probably doesn&apos;t work for all locales
      const without = new Intl.DateTimeFormat(locale, intl).format(date),
        included = new Intl.DateTimeFormat(locale, modified).format(date),
        diffed = included.substring(without.length),
        trimmed = diffed.replace(/^[, ]+/, &apos;&apos;);
      return trimmed;
    } else {
      return null;
    }
  }

  // signedOffset(&apos;-5&apos;, &apos;30&apos;) -&gt; -330
  static signedOffset(offHourStr, offMinuteStr) {
    const offHour = parseInt(offHourStr, 10) || 0,
      offMin = parseInt(offMinuteStr, 10) || 0,
      offMinSigned = offHour &lt; 0 ? -offMin : offMin;
    return offHour * 60 + offMinSigned;
  }

  // COERCION

  static friendlyDuration(duration) {
    if (Util.isNumber(duration)) {
      return Duration.fromMillis(duration);
    } else if (duration instanceof Duration) {
      return duration;
    } else if (duration instanceof Object) {
      return Duration.fromObject(duration);
    } else {
      throw new InvalidArgumentError(&apos;Unknown duration argument&apos;);
    }
  }

  static friendlyDateTime(dateTimeish) {
    if (dateTimeish instanceof DateTime) {
      return dateTimeish;
    } else if (dateTimeish.valueOf &amp;&amp; Util.isNumber(dateTimeish.valueOf())) {
      return DateTime.fromJSDate(dateTimeish);
    } else if (dateTimeish instanceof Object) {
      return DateTime.fromObject(dateTimeish);
    } else {
      throw new InvalidArgumentError(&apos;Unknown datetime argument&apos;);
    }
  }

  static normalizeZone(input) {
    if (Util.isUndefined(input) || input === null) {
      return LocalZone.instance;
    } else if (input instanceof Zone) {
      return input;
    } else if (Util.isString(input)) {
      const lowered = input.toLowerCase();
      if (lowered === &apos;local&apos;) return LocalZone.instance;
      else if (lowered === &apos;utc&apos;) return FixedOffsetZone.utcInstance;
      else if (IANAZone.isValidSpecier(lowered)) return new IANAZone(input);
      else return FixedOffsetZone.parseSpecifier(lowered) || Settings.defaultZone;
    } else if (Util.isNumber(input)) {
      return FixedOffsetZone.instance(input);
    } else if (typeof input === &apos;object&apos; &amp;&amp; input.offset) {
      // This is dumb, but the instanceof check above doesn&apos;t seem to really work
      // so we&apos;re duck checking it
      return input;
    } else {
      return Settings.defaultZone;
    }
  }

  static normalizeObject(obj, normalizer, ignoreUnknown = false) {
    const normalized = {};
    for (const u in obj) {
      if (obj.hasOwnProperty(u)) {
        const v = obj[u];
        if (v !== null &amp;&amp; !Util.isUndefined(v) &amp;&amp; !Number.isNaN(v)) {
          const mapped = normalizer(u, ignoreUnknown);
          if (mapped) {
            normalized[mapped] = v;
          }
        }
      }
    }
    return normalized;
  }

  static timeObject(obj) {
    return Util.pick(obj, [&apos;hour&apos;, &apos;minute&apos;, &apos;second&apos;, &apos;millisecond&apos;]);
  }

  // CAPABILITIES

  static hasIntl() {
    return typeof Intl !== &apos;undefined&apos; &amp;&amp; Intl.DateTimeFormat;
  }

  static hasFormatToParts() {
    return !Util.isUndefined(Intl.DateTimeFormat.prototype.formatToParts);
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
<script src="https://moment.github.io/luxon/global/luxon.js"></script></body>
</html>
